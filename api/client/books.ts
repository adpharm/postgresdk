/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by PostgreSDK.
 * Any manual changes will be overwritten on the next generation.
 *
 * To make changes, modify your schema or configuration and regenerate.
 */
import { BaseClient } from "./base-client";
import type { Where } from "./where-types";
import type { PaginatedResponse } from "./types/shared";
import type { InsertBooks, UpdateBooks, SelectBooks } from "./types/books";
import type { SelectAuthors } from "./types/authors";
import type { SelectTags } from "./types/tags";

/**
 * Client for books table operations
 */
export class BooksClient extends BaseClient {
  private readonly resource = "/v1/books";

  /**
   * Create a new books record
   * @param data - The data to insert
   * @returns The created record
   */
  async create(data: InsertBooks): Promise<SelectBooks> {
    return this.post<SelectBooks>(this.resource, data);
  }

  /**
   * Get a books record by primary key
   * @param pk - The primary key value
   * @returns The record if found, null otherwise
   */
  async getByPk(pk: string): Promise<SelectBooks | null> {
    const path = pk;
    return this.get<SelectBooks | null>(`${this.resource}/${path}`);
  }

  /**
   * List books records with pagination and filtering
   * @param params - Query parameters
   * @param params.where - Filter conditions using operators like $eq, $gt, $in, $like, etc.
   * @param params.orderBy - Column(s) to sort by
   * @param params.order - Sort direction(s): "asc" or "desc"
   * @param params.limit - Maximum number of records to return (default: 50, max: 100)
   * @param params.offset - Number of records to skip for pagination
   * @param params.include - Related records to include (see listWith* methods for typed includes)
   * @returns Paginated results with data, total count, and hasMore flag
   */
  async list(params?: {
    include?: any;
    limit?: number;
    offset?: number;
    where?: Where<SelectBooks>;
    orderBy?: string | string[];
    order?: "asc" | "desc" | ("asc" | "desc")[];
  }): Promise<PaginatedResponse<SelectBooks>> {
    return this.post<PaginatedResponse<SelectBooks>>(`${this.resource}/list`, params ?? {});
  }

  /**
   * Update a books record by primary key
   * @param pk - The primary key value
   * @param patch - Partial data to update
   * @returns The updated record if found, null otherwise
   */
  async update(pk: string, patch: UpdateBooks): Promise<SelectBooks | null> {
    const path = pk;
    return this.patch<SelectBooks | null>(`${this.resource}/${path}`, patch);
  }

  /**
   * Delete a books record by primary key
   * @param pk - The primary key value
   * @returns The deleted record if found, null otherwise
   */
  async delete(pk: string): Promise<SelectBooks | null> {
    const path = pk;
    return this.del<SelectBooks | null>(`${this.resource}/${path}`);
  }

  /**
   * List books records with included related author
   * @param params - Query parameters (where, orderBy, order, limit, offset)
   * @returns Paginated results with nested author included
   */
  async listWithAuthor(params?: Omit<{ limit?: number; offset?: number; where?: Where<SelectBooks>; orderBy?: string | string[]; order?: "asc" | "desc" | ("asc" | "desc")[]; }, "include">): Promise<PaginatedResponse<SelectBooks & { author: SelectAuthors }>> {
    return this.post<PaginatedResponse<SelectBooks & { author: SelectAuthors }>>(`${this.resource}/list`, { ...params, include: {"author":true} });
  }

  /**
   * Get a books record by primary key with included related author
   * @param pk - The primary key value
   * @returns The record with nested author if found, null otherwise
   */
  async getByPkWithAuthor(pk: string): Promise<SelectBooks & { author: SelectAuthors } | null> {
    const results = await this.post<PaginatedResponse<SelectBooks & { author: SelectAuthors }>>(`${this.resource}/list`, {
      where: { id: pk },
      include: {"author":true},
      limit: 1
    });
    return (results.data[0] as SelectBooks & { author: SelectAuthors }) ?? null;
  }

  /**
   * List books records with included related tags
   * @param params - Query parameters (where, orderBy, order, limit, offset)
   * @returns Paginated results with nested tags included
   */
  async listWithTags(params?: Omit<{ limit?: number; offset?: number; where?: Where<SelectBooks>; orderBy?: string | string[]; order?: "asc" | "desc" | ("asc" | "desc")[]; }, "include">): Promise<PaginatedResponse<SelectBooks & { tags: SelectTags[] }>> {
    return this.post<PaginatedResponse<SelectBooks & { tags: SelectTags[] }>>(`${this.resource}/list`, { ...params, include: {"tags":true} });
  }

  /**
   * Get a books record by primary key with included related tags
   * @param pk - The primary key value
   * @returns The record with nested tags if found, null otherwise
   */
  async getByPkWithTags(pk: string): Promise<SelectBooks & { tags: SelectTags[] } | null> {
    const results = await this.post<PaginatedResponse<SelectBooks & { tags: SelectTags[] }>>(`${this.resource}/list`, {
      where: { id: pk },
      include: {"tags":true},
      limit: 1
    });
    return (results.data[0] as SelectBooks & { tags: SelectTags[] }) ?? null;
  }

  /**
   * List books records with included related author -> tags
   * @param params - Query parameters (where, orderBy, order, limit, offset)
   * @returns Paginated results with nested author and tags included
   */
  async listWithAuthorAndTags(params?: Omit<{ limit?: number; offset?: number; where?: Where<SelectBooks>; orderBy?: string | string[]; order?: "asc" | "desc" | ("asc" | "desc")[]; }, "include">): Promise<PaginatedResponse<SelectBooks & { author: SelectAuthors; tags: SelectTags[] }>> {
    return this.post<PaginatedResponse<SelectBooks & { author: SelectAuthors; tags: SelectTags[] }>>(`${this.resource}/list`, { ...params, include: {"author":true,"tags":true} });
  }

  /**
   * Get a books record by primary key with included related author -> tags
   * @param pk - The primary key value
   * @returns The record with nested author and tags if found, null otherwise
   */
  async getByPkWithAuthorAndTags(pk: string): Promise<(SelectBooks & { author: SelectAuthors; tags: SelectTags[] }) | null> {
    const results = await this.post<PaginatedResponse<(SelectBooks & { author: SelectAuthors; tags: SelectTags[] })>>(`${this.resource}/list`, {
      where: { id: pk },
      include: {"author":true,"tags":true},
      limit: 1
    });
    return (results.data[0] as (SelectBooks & { author: SelectAuthors; tags: SelectTags[] })) ?? null;
  }
}
