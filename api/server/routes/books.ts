/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by PostgreSDK.
 * Any manual changes will be overwritten on the next generation.
 *
 * To make changes, modify your schema or configuration and regenerate.
 */
import { Hono } from "hono";
import type { Context } from "hono";
import { z } from "zod";
import { InsertBooksSchema, UpdateBooksSchema } from "../zod/books";
import { loadIncludes } from "../include-loader";
import * as coreOps from "../core/operations";


const columnEnum = z.enum(["id", "author_id", "title"]);

const listSchema = z.object({
  where: z.any().optional(),
  include: z.any().optional(),
  limit: z.number().int().positive().max(1000).optional(),
  offset: z.number().int().min(0).optional(),
  orderBy: z.union([columnEnum, z.array(columnEnum)]).optional(),
  order: z.union([z.enum(["asc", "desc"]), z.array(z.enum(["asc", "desc"]))]).optional()
});

/**
 * Register all CRUD routes for the books table
 * @param app - Hono application instance
 * @param deps - Dependencies including database client and optional request hook
 * @param deps.pg - PostgreSQL client with query method
 * @param deps.onRequest - Optional hook that runs before each request (for audit logging, RLS, etc.)
 */
export function registerBooksRoutes(app: Hono, deps: { pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }, onRequest?: (c: Context, pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }) => Promise<void> }) {
  const base = "/v1/books";
  
  // Create operation context
  const ctx: coreOps.OperationContext = {
    pg: deps.pg,
    table: "books",
    pkColumns: ["id"],
    softDeleteColumn: null,
    includeMethodsDepth: 2
  };


  // CREATE
  app.post(base, async (c) => {
    const body = await c.req.json().catch(() => ({}));
    const parsed = InsertBooksSchema.safeParse(body);

    if (!parsed.success) {
      const issues = parsed.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const result = await coreOps.createRecord(ctx, parsed.data);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    return c.json(result.data, result.status as any);
  });

  // GET BY PK
  app.get(`${base}/:id`, async (c) => {
    const pkValues = [c.req.param("id")];

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const result = await coreOps.getByPk(ctx, pkValues);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    return c.json(result.data, result.status as any);
  });

  // LIST
  app.post(`${base}/list`, async (c) => {
    const body = listSchema.safeParse(await c.req.json().catch(() => ({})));

    if (!body.success) {
      const issues = body.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const result = await coreOps.listRecords(ctx, body.data);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    // Handle includes if needed
    if (result.needsIncludes && result.includeSpec) {
      try {
        const stitched = await loadIncludes(
          "books",
          result.data,
          result.includeSpec,
          deps.pg,
          2
        );
        return c.json({
          data: stitched,
          total: result.total,
          limit: result.limit,
          offset: result.offset,
          hasMore: result.hasMore
        });
      } catch (e: any) {
        const strict = process.env.SDK_STRICT_INCLUDE === "1";
        if (strict) {
          return c.json({
            error: "include-stitch-failed",
            message: e?.message,
            ...(process.env.SDK_DEBUG === "1" ? { stack: e?.stack } : {})
          }, 500);
        }
        // Non-strict: return base rows with error metadata
        return c.json({
          data: result.data,
          total: result.total,
          limit: result.limit,
          offset: result.offset,
          hasMore: result.hasMore,
          includeError: {
            message: e?.message,
            ...(process.env.SDK_DEBUG === "1" ? { stack: e?.stack } : {})
          }
        }, 200);
      }
    }

    return c.json({
      data: result.data,
      total: result.total,
      limit: result.limit,
      offset: result.offset,
      hasMore: result.hasMore
    }, result.status as any);
  });

  // UPDATE
  app.patch(`${base}/:id`, async (c) => {
    const pkValues = [c.req.param("id")];
    const body = await c.req.json().catch(() => ({}));
    const parsed = UpdateBooksSchema.safeParse(body);

    if (!parsed.success) {
      const issues = parsed.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const result = await coreOps.updateRecord(ctx, pkValues, parsed.data);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    return c.json(result.data, result.status as any);
  });

  // DELETE
  app.delete(`${base}/:id`, async (c) => {
    const pkValues = [c.req.param("id")];

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const result = await coreOps.deleteRecord(ctx, pkValues);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    return c.json(result.data, result.status as any);
  });
}
