/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by PostgreSDK.
 * Any manual changes will be overwritten on the next generation.
 *
 * To make changes, modify your schema or configuration and regenerate.
 */
import { Hono } from "hono";
import type { Context } from "hono";
import { SDK_MANIFEST } from "./sdk-bundle";
import { getContract } from "./contract";
import { registerAuthorsRoutes } from "./routes/authors";
import { registerBookTagsRoutes } from "./routes/book_tags";
import { registerBooksRoutes } from "./routes/books";
import { registerProductsRoutes } from "./routes/products";
import { registerTagsRoutes } from "./routes/tags";
import { registerUsersRoutes } from "./routes/users";


/**
 * Creates a Hono router with all generated routes that can be mounted into your existing app.
 *
 * @example
 * import { Hono } from "hono";
 * import { createRouter } from "./generated/server/router";
 *
 * // Using pg driver (Node.js)
 * import { Client } from "pg";
 * const pg = new Client({ connectionString: process.env.DATABASE_URL });
 * await pg.connect();
 *
 * // OR using Neon driver (Edge-compatible)
 * import { Pool } from "@neondatabase/serverless";
 * const pool = new Pool({ connectionString: process.env.DATABASE_URL! });
 * const pg = pool; // Pool already has the compatible query method
 *
 * // Mount all generated routes
 * const app = new Hono();
 * const apiRouter = createRouter({ pg });
 * app.route("/api", apiRouter);
 *
 * // Or mount directly at root
 * const router = createRouter({ pg });
 * app.route("/", router);
 *
 * // With onRequest hook for audit logging or session variables
 * const router = createRouter({
 *   pg,
 *   onRequest: async (c, pg) => {
 *     const auth = c.get('auth'); // Type-safe! IDE autocomplete works
 *     if (auth?.kind === 'jwt' && auth.claims?.sub) {
 *       await pg.query(`SET LOCAL app.user_id = '${auth.claims.sub}'`);
 *     }
 *   }
 * });
 */
export function createRouter(
  deps: {
    pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> },
    onRequest?: (c: Context, pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }) => Promise<void>
  }
): Hono {
  const router = new Hono();
  
  // Register table routes
  registerAuthorsRoutes(router, deps);
  registerBookTagsRoutes(router, deps);
  registerBooksRoutes(router, deps);
  registerProductsRoutes(router, deps);
  registerTagsRoutes(router, deps);
  registerUsersRoutes(router, deps);

  // SDK distribution endpoints
  router.get("/_psdk/sdk/manifest", (c) => {
    return c.json({
      version: SDK_MANIFEST.version,
      generated: SDK_MANIFEST.generated,
      files: Object.keys(SDK_MANIFEST.files)
    });
  });

  router.get("/_psdk/sdk/download", (c) => {
    return c.json(SDK_MANIFEST);
  });

  router.get("/_psdk/sdk/files/:path{.*}", (c) => {
    const path = c.req.param("path");
    const content = SDK_MANIFEST.files[path as keyof typeof SDK_MANIFEST.files];
    if (!content) {
      return c.text("File not found", 404);
    }
    return c.text(content, 200, {
      "Content-Type": "text/plain; charset=utf-8"
    });
  });

  // API Contract endpoints - describes the entire API
  router.get("/_psdk/contract", (c) => {
    const format = c.req.query("format") || "json";

    if (format === "markdown") {
      return c.text(getContract("markdown") as string, 200, {
        "Content-Type": "text/markdown; charset=utf-8"
      });
    }

    return c.json(getContract("json"));
  });

  router.get("/_psdk/contract.json", (c) => {
    return c.json(getContract("json"));
  });

  router.get("/_psdk/contract.md", (c) => {
    return c.text(getContract("markdown") as string, 200, {
      "Content-Type": "text/markdown; charset=utf-8"
    });
  });
  
  return router;
}

/**
 * Register all generated routes directly on an existing Hono app.
 *
 * @example
 * import { Hono } from "hono";
 * import { registerAllRoutes } from "./generated/server/router";
 *
 * const app = new Hono();
 *
 * // Setup database connection (see createRouter example for both pg and Neon options)
 * const pg = yourDatabaseClient;
 *
 * // Register all routes at once
 * registerAllRoutes(app, { pg });
 *
 * // With onRequest hook
 * registerAllRoutes(app, {
 *   pg,
 *   onRequest: async (c, pg) => {
 *     const auth = c.get('auth'); // Type-safe!
 *     if (auth?.kind === 'jwt' && auth.claims?.sub) {
 *       await pg.query(`SET LOCAL app.user_id = '${auth.claims.sub}'`);
 *     }
 *   }
 * });
 */
export function registerAllRoutes(
  app: Hono,
  deps: {
    pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> },
    onRequest?: (c: Context, pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }) => Promise<void>
  }
) {
  registerAuthorsRoutes(app, deps);
  registerBookTagsRoutes(app, deps);
  registerBooksRoutes(app, deps);
  registerProductsRoutes(app, deps);
  registerTagsRoutes(app, deps);
  registerUsersRoutes(app, deps);
}

// Individual route registrations (for selective use)
export { registerAuthorsRoutes } from "./routes/authors";
export { registerBookTagsRoutes } from "./routes/book_tags";
export { registerBooksRoutes } from "./routes/books";
export { registerProductsRoutes } from "./routes/products";
export { registerTagsRoutes } from "./routes/tags";
export { registerUsersRoutes } from "./routes/users";

// Re-export types and schemas for convenience
export * from "./include-spec";
