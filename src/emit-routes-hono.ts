/**
 * Hono-specific route generation that uses core operations
 */

import type { Table } from "./introspect";
import type { Graph } from "./rel-classify";
import { pascal } from "./utils";

/**
 * Check if a PostgreSQL type is a vector type (vector, halfvec, sparsevec, bit)
 */
function isVectorType(pgType: string): boolean {
  const t = pgType.toLowerCase();
  return t === "vector" || t === "halfvec" || t === "sparsevec" || t === "bit";
}

export function emitHonoRoutes(
  table: Table,
  _graph: Graph,
  opts: { softDeleteColumn: string | null; includeMethodsDepth: number; authStrategy?: string; useJsExtensions?: boolean; apiPathPrefix: string }
) {
  const fileTableName = table.name;
  const Type = pascal(table.name);

  // Check if table has any vector columns
  const hasVectorColumns = table.columns.some(c => isVectorType(c.pgType));
  const vectorColumns = table.columns.filter(c => isVectorType(c.pgType)).map(c => c.name);
  
  // Normalize pk to an array and fallback to ["id"] if empty
  const rawPk = (table as any).pk;
  const pkCols: string[] = Array.isArray(rawPk) ? rawPk : rawPk ? [rawPk] : [];
  const safePkCols = pkCols.length ? pkCols : ["id"];
  
  const hasCompositePk = safePkCols.length > 1;
  const pkPath = hasCompositePk ? safePkCols.map((c) => `:${c}`).join("/") : `:${safePkCols[0]}`;
  
  const softDel = opts.softDeleteColumn && table.columns.some((c) => c.name === opts.softDeleteColumn) 
    ? opts.softDeleteColumn 
    : null;
  
  const getPkParams = hasCompositePk
    ? `const pkValues = [${safePkCols.map((c) => `c.req.param("${c}")`).join(", ")}];`
    : `const pkValues = [c.req.param("${safePkCols[0]}")];`;
  
  const hasAuth = opts.authStrategy && opts.authStrategy !== "none";
  const ext = opts.useJsExtensions ? ".js" : "";
  const authImport = hasAuth ? `import { authMiddleware } from "../auth${ext}";` : "";

  // Generate column name enum for orderBy validation
  const columnNames = table.columns.map(c => `"${c.name}"`).join(", ");

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by PostgreSDK.
 * Any manual changes will be overwritten on the next generation.
 *
 * To make changes, modify your schema or configuration and regenerate.
 */
import { Hono } from "hono";
import type { Context } from "hono";
import { z } from "zod";
import { Insert${Type}Schema, Update${Type}Schema } from "../zod/${fileTableName}${ext}";
import { loadIncludes } from "../include-loader${ext}";
import * as coreOps from "../core/operations${ext}";
${authImport}

const columnEnum = z.enum([${columnNames}]);

const createSchema = Insert${Type}Schema;
const updateSchema = Update${Type}Schema;

const deleteSchema = z.object({
  select: z.array(z.string()).min(1).optional(),
  exclude: z.array(z.string()).min(1).optional()
}).strict().refine(
  (data) => !(data.select && data.exclude),
  { message: "Cannot specify both 'select' and 'exclude' parameters" }
);

const getByPkQuerySchema = z.object({
  select: z.array(z.string()).min(1).optional(),
  exclude: z.array(z.string()).min(1).optional()
}).strict().refine(
  (data) => !(data.select && data.exclude),
  { message: "Cannot specify both 'select' and 'exclude' parameters" }
);

const listSchema = z.object({
  where: z.any().optional(),
  include: z.any().optional(),
  select: z.array(z.string()).min(1).optional(),
  exclude: z.array(z.string()).min(1).optional(),
  limit: z.number().int().positive().max(1000).optional(),
  offset: z.number().int().min(0).optional(),
  orderBy: z.union([columnEnum, z.array(columnEnum)]).optional(),
  order: z.union([z.enum(["asc", "desc"]), z.array(z.enum(["asc", "desc"]))]).optional(),${hasVectorColumns ? `
  vector: z.object({
    field: z.string(),
    query: z.array(z.number()),
    metric: z.enum(["cosine", "l2", "inner"]).optional(),
    maxDistance: z.number().optional()
  }).optional()` : ""}
}).strict().refine(
  (data) => !(data.select && data.exclude),
  { message: "Cannot specify both 'select' and 'exclude' parameters" }
);

/**
 * Register all CRUD routes for the ${fileTableName} table
 * @param app - Hono application instance
 * @param deps - Dependencies including database client and optional request hook
 * @param deps.pg - PostgreSQL client with query method
 * @param deps.onRequest - Optional hook that runs before each request (for audit logging, RLS, etc.)
 */
export function register${Type}Routes(app: Hono, deps: { pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }, onRequest?: (c: Context, pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> }) => Promise<void> }) {
  const base = "${opts.apiPathPrefix}/${fileTableName}";
  
  // Create operation context
  const baseCtx: coreOps.OperationContext = {
    pg: deps.pg,
    table: "${fileTableName}",
    pkColumns: ${JSON.stringify(safePkCols)},
    softDeleteColumn: ${softDel ? `"${softDel}"` : "null"},
    includeMethodsDepth: ${opts.includeMethodsDepth},
    allColumnNames: [${table.columns.map(c => `"${c.name}"`).join(", ")}]${vectorColumns.length > 0 ? `,\n    vectorColumns: ${JSON.stringify(vectorColumns)}` : ""}
  };
${hasAuth ? `
  // ðŸ” Auth: protect all routes for this table
  app.use(base, authMiddleware);
  app.use(\`\${base}/*\`, authMiddleware);` : ""}

  // CREATE
  app.post(base, async (c) => {
    const body = await c.req.json().catch(() => ({}));
    const parsed = createSchema.safeParse(body);

    if (!parsed.success) {
      const issues = parsed.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    // Get select/exclude from query params
    const selectParam = c.req.query("select");
    const excludeParam = c.req.query("exclude");
    const select = selectParam ? selectParam.split(",") : undefined;
    const exclude = excludeParam ? excludeParam.split(",") : undefined;

    if (select && exclude) {
      return c.json({ error: "Cannot specify both 'select' and 'exclude' parameters" }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const ctx = { ...baseCtx, select, exclude };
    const result = await coreOps.createRecord(ctx, parsed.data);

    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }

    return c.json(result.data, result.status as any);
  });

  // GET BY PK
  app.get(\`\${base}/${pkPath}\`, async (c) => {
    ${getPkParams}

    // Parse query params for select/exclude
    const selectParam = c.req.query("select");
    const excludeParam = c.req.query("exclude");
    const queryData: any = {};
    if (selectParam) queryData.select = selectParam.split(",");
    if (excludeParam) queryData.exclude = excludeParam.split(",");

    const queryParsed = getByPkQuerySchema.safeParse(queryData);
    if (!queryParsed.success) {
      const issues = queryParsed.error.flatten();
      return c.json({ error: "Invalid query parameters", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const ctx = { ...baseCtx, select: queryParsed.data.select, exclude: queryParsed.data.exclude };
    const result = await coreOps.getByPk(ctx, pkValues);

    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }

    return c.json(result.data, result.status as any);
  });

  // LIST
  app.post(\`\${base}/list\`, async (c) => {
    const body = listSchema.safeParse(await c.req.json().catch(() => ({})));

    if (!body.success) {
      const issues = body.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const ctx = { ...baseCtx, select: body.data.select, exclude: body.data.exclude };
    const result = await coreOps.listRecords(ctx, body.data);
    
    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }
    
    // Handle includes if needed
    if (result.needsIncludes && result.includeSpec) {
      try {
        const stitched = await loadIncludes(
          "${fileTableName}",
          result.data,
          result.includeSpec,
          deps.pg,
          ${opts.includeMethodsDepth}
        );
        return c.json({
          data: stitched,
          total: result.total,
          limit: result.limit,
          offset: result.offset,
          hasMore: result.hasMore
        });
      } catch (e: any) {
        const strict = process.env.SDK_STRICT_INCLUDE === "1";
        if (strict) {
          return c.json({
            error: "include-stitch-failed",
            message: e?.message,
            ...(process.env.SDK_DEBUG === "1" ? { stack: e?.stack } : {})
          }, 500);
        }
        // Non-strict: return base rows with error metadata
        return c.json({
          data: result.data,
          total: result.total,
          limit: result.limit,
          offset: result.offset,
          hasMore: result.hasMore,
          includeError: {
            message: e?.message,
            ...(process.env.SDK_DEBUG === "1" ? { stack: e?.stack } : {})
          }
        }, 200);
      }
    }

    return c.json({
      data: result.data,
      total: result.total,
      limit: result.limit,
      offset: result.offset,
      hasMore: result.hasMore
    }, result.status as any);
  });

  // UPDATE
  app.patch(\`\${base}/${pkPath}\`, async (c) => {
    ${getPkParams}
    const body = await c.req.json().catch(() => ({}));
    const parsed = updateSchema.safeParse(body);

    if (!parsed.success) {
      const issues = parsed.error.flatten();
      return c.json({ error: "Invalid body", issues }, 400);
    }

    // Get select/exclude from query params
    const selectParam = c.req.query("select");
    const excludeParam = c.req.query("exclude");
    const select = selectParam ? selectParam.split(",") : undefined;
    const exclude = excludeParam ? excludeParam.split(",") : undefined;

    if (select && exclude) {
      return c.json({ error: "Cannot specify both 'select' and 'exclude' parameters" }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const ctx = { ...baseCtx, select, exclude };
    const result = await coreOps.updateRecord(ctx, pkValues, parsed.data);

    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }

    return c.json(result.data, result.status as any);
  });

  // DELETE
  app.delete(\`\${base}/${pkPath}\`, async (c) => {
    ${getPkParams}

    // Parse query params for select/exclude
    const selectParam = c.req.query("select");
    const excludeParam = c.req.query("exclude");
    const queryData: any = {};
    if (selectParam) queryData.select = selectParam.split(",");
    if (excludeParam) queryData.exclude = excludeParam.split(",");

    const queryParsed = deleteSchema.safeParse(queryData);
    if (!queryParsed.success) {
      const issues = queryParsed.error.flatten();
      return c.json({ error: "Invalid query parameters", issues }, 400);
    }

    if (deps.onRequest) {
      await deps.onRequest(c, deps.pg);
    }

    const ctx = { ...baseCtx, select: queryParsed.data.select, exclude: queryParsed.data.exclude };
    const result = await coreOps.deleteRecord(ctx, pkValues);

    if (result.error) {
      return c.json({ error: result.error }, result.status as any);
    }

    return c.json(result.data, result.status as any);
  });
}
`;
}