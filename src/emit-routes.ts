import type { Table } from "./introspect";
import type { Graph } from "./rel-classify";
import { pascal } from "./utils";

/**
 * Emits a Hono router for one table, using generated Zod schemas.
 *
 * Expects:
 *   - Generated file at ../zod/<table>.ts exporting Insert<Type>Schema & Update<Type>Schema
 *   - deps: { pg: Pool | Client } with .query(text, params)
 *
 * Endpoints:
 *   POST   /v1/<table>           create (Insert<Type>Schema)
 *   GET    /v1/<table>/:...pk    get by pk
 *   POST   /v1/<table>/list      list (limit/offset; includes)
 *   PATCH  /v1/<table>/:...pk    update (Update<Type>Schema)
 *   DELETE /v1/<table>/:...pk    delete (or soft-delete)
 */
export function emitRoutes(
  table: Table,
  _graph: Graph,
  opts: { softDeleteColumn: string | null; includeMethodsDepth: number; authStrategy?: string }
) {
  const fileTableName = table.name; // SQL table name for file/route
  const Type = pascal(table.name); // PascalCase for type/schemas

  // Normalize pk to an array and fallback to ["id"] if empty
  const rawPk = (table as any).pk;
  const pkCols: string[] = Array.isArray(rawPk) ? rawPk : rawPk ? [rawPk] : [];
  const safePkCols = pkCols.length ? pkCols : ["id"];

  const hasCompositePk = safePkCols.length > 1;
  const pkPath = hasCompositePk ? safePkCols.map((c) => `:${c}`).join("/") : `:${safePkCols[0]}`;

  const softDel =
    opts.softDeleteColumn && table.columns.some((c) => c.name === opts.softDeleteColumn) ? opts.softDeleteColumn : null;

  // IMPORTANT: interpolate column names at generator time (no escaping/backslashes here)
  const wherePkSql = hasCompositePk
    ? safePkCols.map((c, i) => `"${c}" = $${i + 1}`).join(" AND ")
    : `"${safePkCols[0]}" = $1`;

  const getPkParams = hasCompositePk
    ? `const pkValues = [${safePkCols.map((c) => `c.req.param("${c}")`).join(", ")}];`
    : `const pkValues = [c.req.param("${safePkCols[0]}")];`;

  // Build SET clause indices for UPDATE (PK params first, then update values)
  // These strings are emitted into generated code, so we DO escape ${...} intentionally here.
  const updateSetSql = hasCompositePk
    ? `Object.keys(updateData).map((k, i) => \`"\${k}" = $\${i + ${safePkCols.length} + 1}\`).join(", ")`
    : `Object.keys(updateData).map((k, i) => \`"\${k}" = $\${i + 2}\`).join(", ")`;

  // Prevent updating PK columns
  const pkFilter = safePkCols.length
    ? `const updateData = Object.fromEntries(Object.entries(parsed.data).filter(([k]) => !new Set(${JSON.stringify(
        safePkCols
      )}).has(k)));`
    : `const updateData = parsed.data;`;

  const hasAuth = opts.authStrategy && opts.authStrategy !== "none";
  const authImport = hasAuth ? `import { authMiddleware } from "../auth";` : "";

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * This file was automatically generated by PostgreSDK.
 * Any manual changes will be overwritten on the next generation.
 *
 * To make changes, modify your schema or configuration and regenerate.
 */
import { Hono } from "hono";
import { z } from "zod";
import { Insert${Type}Schema, Update${Type}Schema } from "../zod/${fileTableName}";
import { loadIncludes } from "../include-loader";
${authImport}

const DEBUG = process.env.SDK_DEBUG === "1" || process.env.SDK_DEBUG === "true";
const log = {
  debug: (...args: any[]) => { if (DEBUG) console.debug("[sdk]", ...args); },
  error: (...args: any[]) => console.error("[sdk]", ...args),
};

const listSchema = z.object({
  where: z.any().optional(),           // TODO: typed where clause in later pass
  include: z.any().optional(),         // TODO: typed include spec in later pass
  limit: z.number().int().positive().max(1000).optional(),
  offset: z.number().int().min(0).optional(),
  orderBy: z.any().optional()          // TODO: typed orderBy in a later pass
});

export function register${Type}Routes(app: Hono, deps: { pg: { query: (text: string, params?: any[]) => Promise<{ rows: any[] }> } }) {
  const base = "/v1/${fileTableName}";
${hasAuth ? `
  // ðŸ” Auth: protect all routes for this table
  app.use(base, authMiddleware);
  app.use(\`\${base}/*\`, authMiddleware);` : ""}

  // CREATE
  app.post(base, async (c) => {
    try {
      const body = await c.req.json().catch(() => ({}));
      log.debug("POST ${fileTableName} body:", body);
      const parsed = Insert${Type}Schema.safeParse(body);
      if (!parsed.success) {
        const issues = parsed.error.flatten();
        log.debug("POST ${fileTableName} invalid:", issues);
        return c.json({ error: "Invalid body", issues }, 400);
      }

      const data = parsed.data;
      const cols = Object.keys(data);
      const vals = Object.values(data);
      if (!cols.length) return c.json({ error: "No fields provided" }, 400);

      const placeholders = cols.map((_, i) => '$' + (i + 1)).join(", ");
      const text = \`INSERT INTO "${fileTableName}" (\${cols.map(c => '"' + c + '"').join(", ")})
                     VALUES (\${placeholders})
                     RETURNING *\`;
      log.debug("SQL:", text, "vals:", vals);
      const { rows } = await deps.pg.query(text, vals);
      return c.json(rows[0] ?? null, rows[0] ? 201 : 500);
    } catch (e: any) {
      log.error("POST ${fileTableName} error:", e?.stack ?? e);
      return c.json({ error: e?.message ?? "Internal error", ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
    }
  });

  // GET BY PK
  app.get(\`\${base}/${pkPath}\`, async (c) => {
    try {
      ${getPkParams}
      const text = \`SELECT * FROM "${fileTableName}" WHERE ${wherePkSql} LIMIT 1\`;
      log.debug("GET ${fileTableName} by PK:", pkValues, "SQL:", text);
      const { rows } = await deps.pg.query(text, pkValues);
      if (!rows[0]) return c.json(null, 404);
      return c.json(rows[0]);
    } catch (e: any) {
      log.error("GET ${fileTableName} error:", e?.stack ?? e);
      return c.json({ error: e?.message ?? "Internal error", ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
    }
  });

  // LIST
  app.post(\`\${base}/list\`, async (c) => {
    try {
      const body = listSchema.safeParse(await c.req.json().catch(() => ({})));
      if (!body.success) {
        const issues = body.error.flatten();
        log.debug("LIST ${fileTableName} invalid:", issues);
        return c.json({ error: "Invalid body", issues }, 400);
      }
      const { include, limit = 50, offset = 0 } = body.data;

      const where = ${softDel ? `\`WHERE "${softDel}" IS NULL\`` : `""`};

      // Get total count for pagination
      const countText = \`SELECT COUNT(*) FROM "${fileTableName}" \${where}\`;
      log.debug("LIST ${fileTableName} COUNT SQL:", countText);
      const countResult = await deps.pg.query(countText);
      const total = parseInt(countResult.rows[0].count, 10);

      const text = \`SELECT * FROM "${fileTableName}" \${where} LIMIT $1 OFFSET $2\`;
      log.debug("LIST ${fileTableName} SQL:", text, "params:", [limit, offset]);
      const { rows } = await deps.pg.query(text, [limit, offset]);

      const hasMore = offset + limit < total;

      if (!include) {
        log.debug("LIST ${fileTableName} rows:", rows.length, "total:", total);
        return c.json({ data: rows, total, limit, offset, hasMore });
      }

      // Attempt include stitching with explicit error handling
      log.debug("LIST ${fileTableName} include spec:", include);
      try {
        const stitched = await loadIncludes("${fileTableName}", rows, include, deps.pg, ${opts.includeMethodsDepth});
        log.debug("LIST ${fileTableName} stitched count:", Array.isArray(stitched) ? stitched.length : "n/a");
        return c.json({ data: stitched, total, limit, offset, hasMore });
      } catch (e: any) {
        const strict = process.env.SDK_STRICT_INCLUDE === "1" || process.env.SDK_STRICT_INCLUDE === "true";
        const msg = e?.message ?? String(e);
        const stack = e?.stack;
        log.error("LIST ${fileTableName} include stitch FAILED:", msg, stack);

        if (strict) {
          return c.json({ error: "include-stitch-failed", message: msg, ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
        }
        // Non-strict fallback: return base rows plus error metadata
        return c.json({ data: rows, total, limit, offset, hasMore, includeError: { message: msg, ...(DEBUG ? { stack: e?.stack } : {}) } }, 200);
      }
    } catch (e: any) {
      log.error("LIST ${fileTableName} error:", e?.stack ?? e);
      return c.json({ error: e?.message ?? "Internal error", ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
    }
  });

  // UPDATE
  app.patch(\`\${base}/${pkPath}\`, async (c) => {
    try {
      ${getPkParams}
      const body = await c.req.json().catch(() => ({}));
      log.debug("PATCH ${fileTableName} pk:", pkValues, "patch:", body);
      const parsed = Update${Type}Schema.safeParse(body);
      if (!parsed.success) {
        const issues = parsed.error.flatten();
        log.debug("PATCH ${fileTableName} invalid:", issues);
        return c.json({ error: "Invalid body", issues: issues }, 400);
      }

      ${pkFilter}
      if (!Object.keys(updateData).length) return c.json({ error: "No updatable fields provided" }, 400);

      const setSql = ${updateSetSql};
      const text = \`UPDATE "${fileTableName}" SET \${setSql} WHERE ${wherePkSql} RETURNING *\`;
      const params = ${
        hasCompositePk ? `[...pkValues, ...Object.values(updateData)]` : `[pkValues[0], ...Object.values(updateData)]`
      };
      log.debug("PATCH ${fileTableName} SQL:", text, "params:", params);
      const { rows } = await deps.pg.query(text, params);
      if (!rows[0]) return c.json(null, 404);
      return c.json(rows[0]);
    } catch (e: any) {
      log.error("PATCH ${fileTableName} error:", e?.stack ?? e);
      return c.json({ error: e?.message ?? "Internal error", ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
    }
  });

  // DELETE (soft or hard)
  app.delete(\`\${base}/${pkPath}\`, async (c) => {
    try {
      ${getPkParams}
      ${
        softDel
          ? `
      const text = \`UPDATE "${fileTableName}" SET "${softDel}" = NOW() WHERE ${wherePkSql} RETURNING *\`;
      log.debug("DELETE (soft) ${fileTableName} SQL:", text, "pk:", pkValues);
      const { rows } = await deps.pg.query(text, pkValues);
      if (!rows[0]) return c.json(null, 404);
      return c.json(rows[0]);`
          : `
      const text = \`DELETE FROM "${fileTableName}" WHERE ${wherePkSql} RETURNING *\`;
      log.debug("DELETE ${fileTableName} SQL:", text, "pk:", pkValues);
      const { rows } = await deps.pg.query(text, pkValues);
      if (!rows[0]) return c.json(null, 404);
      return c.json(rows[0]);`
      }
    } catch (e: any) {
      log.error("DELETE ${fileTableName} error:", e?.stack ?? e);
      return c.json({ error: e?.message ?? "Internal error", ...(DEBUG ? { stack: e?.stack } : {}) }, 500);
    }
  });
}
`;
}
